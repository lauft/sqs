#!/bin/bash

source sqsconfig

queue=""
master="no"
maxproc=0
dryrun="no"
targets=""
call=""
nice="0"
verbose="no"

#_______________________________________________________________________________
usage(){
PROGNAME=${0##*/}
cat << EOF

$PROGNAME, a simple queuing system.

Usage: $PROGNAME [OPTIONS] --call <name> TARGETS

Options:
  --call     define the program call

  --queue    specify the name of the queue
  
  --nproc    maximum number of parallel processes (only if master)

  --nice     set nice level for queue

  --logfile  redirect output of each process to a logfile '<target>.log'

  --dry-run  do not process anything, just print what would happen

  --verbose  give informational output
EOF
exit
}

# Parsing options
while [ ${1:q} ]; do
  case "${1}" in
    --call )
      shift
      call=${1}
      ;;
    --queue )
      shift
      queue=${1}
      ;;
    --nproc )
      shift
      maxproc=${1}
      ;;
    --nice )
      shift
      nice=${1}
      ;;
    --logfile )
      echo "logfile option not yet supported!"
      ;;
    --dry-run )
      dryrun="yes"
      ;;
    --verbose )
      verbose="yes"
      ;;
    -h )
      usage
      exit
      ;;
    --help )
      usage
      exit
      ;;
    -* )
      echo "unknown option ${1}"
      usage
      exit
      ;;
    * )
      targets="${targets} ${1}"
      ;;
  esac
  shift    
done

################################################################################
# script entry point
#
if [ -z "${call}" ] ; then
  echo "sqs: no call specified!"
  usage
  exit 1
fi

if ! which ${call%% *} >/dev/null 2>&1 ; then
  echo "sqs: program call '${call%% *}' is not accessible!"
  exit 2
fi

# export verbosity
export verbose

# create queue name if not yet specified
if [ -z ${queue} ] ; then
  queue=${call##*/}
  queue=${queue%% *}
fi

# build tasklist
if [ "x${targets}" = "x" ] ; then
  tasklist="${call}"
else
  for target in ${targets} ; do
    tasklist="${tasklist};${call} ${target}"
  done
fi

tasklist=${tasklist#;}

# if dry run, stop here
if [ "x${dryrun}" = "xyes" ] ; then
  echo "call : ${call}"
  echo "queue: ${queue}"
  echo "runs : ${maxproc}"
  echo "tasks: ${tasklist}" | sed -e "s|;|\n       |g"
  exit 0
fi

# TODO: add traps

sqslock ${vardir}

if [ "x${verbose}" = "xyes" ] ; then
  echo "sqs: checking for queue ${vardir}/${queue}..."
fi

if [ -e "${vardir}/${queue}" ] ; then
  if [ "x${verbose}" = "xyes" ] ; then
    echo "sqs: queue already exists!"
  fi
  if [ ${maxproc} -gt 0 ] ; then
    echo ${maxproc} > ${vardir}/${queue}/info/nproc
  fi
  echo ${nice}    > ${vardir}/${queue}/info/nice
else 
  if [ "x${verbose}" = "xyes" ] ; then
    echo "sqs: queue does not exist, creating new queue!"
  fi
  if [ ${maxproc} -eq 0 ] ; then
    maxproc=1
  fi
  #master="yes"
  mkdir ${vardir}/${queue}
  mkdir ${vardir}/${queue}/wait
  mkdir ${vardir}/${queue}/exec
  mkdir ${vardir}/${queue}/proc
  mkdir ${vardir}/${queue}/info
  echo ${maxproc} > ${vardir}/${queue}/info/nproc
  echo "-1"       > ${vardir}/${queue}/info/ntask
  echo ${nice}    > ${vardir}/${queue}/info/nice
fi

sqslock ${vardir}/${queue}
sqsunlock ${vardir}

separator=$IFS
IFS=";"

for task in ${tasklist} ; do
  i=`cat ${vardir}/${queue}/info/ntask`
  ((i++))
  echo "sqs: add task ${i} '${task}'"
  echo ${task} > ${vardir}/${queue}/wait/${i}
  echo ${i}    > ${vardir}/${queue}/info/ntask
done

IFS=${separator}

sqsunlock ${vardir}/${queue}

# seed sqsrunner
sqsrunner ${vardir}/${queue} &

if [ "x${verbose}" = "xyes" ] ; then
  echo "sqs: finished!"
fi
