#!/bin/bash

source sqsconfig

queue=""
targets=""
call=""
verbose="no"
host=$(hostname)

#_______________________________________________________________________________
usage() {
PROGNAME=${0##*/}
cat << EOF
SQS, a simple queuing system.

Usage: $PROGNAME [OPTIONS] --call <name> [TARGETS]

Options:
  --call     define the program call.

  --queue    specify the name of the queue.
  
  --host     specify host [hostname:processes:nicelevel]
             if hostname is omitted, name of current host is set.

  --nproc    maximum number of parallel processes for host [hostname:processes].
             if hostname is omitted, current host is set.

  --nice     set nice level for queue for host [hostname:nicelevel]
             if hostname is omitted, name of current host is set.
  
  --create-only  only create the queue.

  --persistent  make the queue persistent.

  --logfile  redirect output of each process to a logfile '<target>.log'.

  --dry-run  do not process anything, just print what would happen.

  --verbose  give informational output.
EOF
exit
}

#_______________________________________________________________________________
add_to_hostlist() {
  # add host specification to hostlist
  # 1 = hostname
  # 2 = maximum number of processes
  # 3 = nicelevel
  #
  if [ $# -ne 3 ] ; then
    echo "sqs[add_to_hostlist]: wrong argument count"
    return 1
  fi

	#echo "add_to_hostlist $*"

  # check host
  host ${1} >/dev/null 2>&1 || return 12

  # check process limit
  [[ ${2} =~ [[:digit:]] ]] || return 13

  # check nice level
  [[ ${3} =~ [-]?[[:digit:]] ]] || return 14

	local mm=${1}
	local pp=${2}
	local nn=${3}

	# try to retrieve previous if default values are given
	if [ ${2} -lt 1 ] ; then
		tmp=`echo ${hostlist} | tr ';' '\n' | grep ${mm}`
		test "x${tmp}" = "x" || pp=${tmp#*:} ; pp=${pp%:*}
	fi

	if [ ${3} -lt 0 ] ; then
		tmp=`echo ${hostlist} | tr ';' '\n' | grep ${mm}`
		test "x${tmp}" = "x" || nn=${tmp##*:} ; nn=${nn%;}
	fi

  # delete any previous occurrence of this host
  hostlist=`echo ${hostlist} | sed "s|${mm}:[0-9]*:[-]*[0-9]*;||g"`  
  # add new host specification
  hostlist="${mm}:${pp}:${nn};${hostlist}"

  return 0
} # add_to_hostlist

# Parsing options
while [ ${1:q} ]; do
  case "${1}" in
    --call )
      shift
      call=${1}
      ;;
    --queue )
      shift
      queue=${1}
      ;;
    --nproc )
      shift
      case "${1}" in
        *:[[:digit:]]*)
				  m=${1%:*}
					p=${1#*:}
					;;
        [[:digit:]]*)			
				  m=${host}
					p=${1}
					;;
			esac
      add_to_hostlist ${m} ${p} -1 || { usage ; exit $? ; }
      ;;
    --nice )
      shift
      case "${1}" in
        *:[[:digit:]]*)
				  m=${1%:*}
					n=${1#*:}
					;;				  
        [[:digit:]]*)			
				  m=${host}
					n=${1}
					;;
			esac
      add_to_hostlist ${m} 0 ${n} || { usage ; exit $? ; }
      ;;
    --host )
      shift
      case "${1}" in
        *:[[:digit:]]*:[[:digit:]]*)
				  m=${1%%:*}
					p=${1#*:}; p=${p%:*}
					n=${1##*:}
					;;
        *:[[:digit:]]*)
				  m=${1%:*}
					p=${1#*:}
          n=-1
					;;
				[[:digit:]]*:[[:digit:]]*)
				  m=${host}
          p=${1%:*}
          n=${1#*:}
          ;;
				[[:digit:]]*)
				  m=${host}
					p=${1}
					n=-1
					;;
				*)
				  m=${1}
					p=0
					n=-1
					;;
      esac
      add_to_hostlist ${m} ${p} ${n}
      ;;
    --create-only )
			createonly="yes"
		  ;;
		--persistent )
      persistent="yes"
      ;;
    --logfile )
      echo "logfile option not yet supported!"
      ;;
    --dry-run )
      dryrun="yes"
      ;;
    --verbose )
      verbose="yes"
      ;;
    -h )
      usage
      exit
      ;;
    --help )
      usage
      exit
      ;;
    -* )
      echo "unknown option ${1}"
      usage
      exit
      ;;
    * )
      targets="${targets} ${1}"
      ;;
  esac
  shift    
done

################################################################################
# script entry point
#
# export verbosity
export verbose

# default for hostlist
if [ "x${hostlist}" = "x" ] ; then
  hostlist="${host}:0:-1"
fi

# generate lock key
key="${host}.$$"

# create queue name if not yet specified
if [ "x${queue}" = "x" ] ; then
  if [ "x${call}" = "x" ] ; then
    echo "sqs: no call specified!"
    usage
    exit 1
  fi

  if ! which ${call%% *} >/dev/null 2>&1 ; then
    echo "sqs: program call '${call%% *}' is not accessible!"
    exit 2
  fi

  queue=${call##*/}
  queue=${queue%% *}
fi

# build tasklist
if [ "x${targets}" = "x" ] ; then
  tasklist="${call}"
else
  for target in ${targets} ; do
    tasklist="${tasklist};${call} ${target}"
  done
fi

tasklist=${tasklist#;}
hostlist=${hostlist%;}

# if dry run, stop here
if [ "x${dryrun}" = "xyes" ] ; then
  echo "call : ${call}"
  echo "queue: ${queue}"
  echo "hosts: ${hostlist}" | sed -e "s|;|\n       |g"
  echo "tasks: ${tasklist}" | sed -e "s|;|\n       |g"
  exit 0
fi

# TODO: add traps

sqslock ${vardir} ${key} || exit $?

if [ "x${verbose}" = "xyes" ] ; then
  echo "sqs: checking for queue ${vardir}/${queue}..."
fi

if [ -e "${vardir}/${queue}" ] ; then
  if [ "x${verbose}" = "xyes" ] ; then
    echo "sqs: queue already exists!"
  fi

  separator=${IFS} ; IFS=";"

  for host in ${hostlist} ; do
    m=${host%%:*}
    p=${host#*:}; p=${p%:*}
    n=${host##*:}
      
	  # try to retrieve previous if default values are given
		if [ ${p} -lt 1 ] ; then
		  tmp=`grep ${m} ${vardir}/${queue}/info/nproc`
			if [ "x${tmp}" = "x" ] ; then
				p=1
			else
				p=${tmp#*:} ; p=${p%:*}
			fi
		fi

		if [ ${n} -lt 0 ] ; then
			tmp=`grep ${m} ${vardir}/${queue}/info/nice`
			if [ "x${tmp}" = "x" ] ; then
				n=0
			else
				n=${tmp##*:} ; n=${n%;}
			fi
		fi
		
		# remove previous entries for this host
		grep -v ${m} ${vardir}/${queue}/info/nproc > ${vardir}/${queue}/info/nproc.tmp
		grep -v ${m} ${vardir}/${queue}/info/nice  > ${vardir}/${queue}/info/nice.tmp

		# add new values
		echo "${m}:${p}" >> ${vardir}/${queue}/info/nproc.tmp
    echo "${m}:${n}" >> ${vardir}/${queue}/info/nice.tmp

		mv ${vardir}/${queue}/info/nproc.tmp ${vardir}/${queue}/info/nproc
		mv ${vardir}/${queue}/info/nice.tmp  ${vardir}/${queue}/info/nice
  done
  
  IFS=${separator}
else 
  if [ "x${verbose}" = "xyes" ] ; then
    echo "sqs: queue does not exist, creating new queue!"
  fi
  # setting default value for number of processes where neccessary
  hostlist=`echo ${hostlist} | sed "s|:0:|:1:|g"`
  hostlist=`echo ${hostlist} | sed "s|:-1|:0|g"`
  
  mkdir ${vardir}/${queue}
  mkdir ${vardir}/${queue}/wait
  mkdir ${vardir}/${queue}/exec
  mkdir ${vardir}/${queue}/proc
  mkdir ${vardir}/${queue}/info

  echo "-1"      > ${vardir}/${queue}/info/ntask
	echo "${host}" > ${vardir}/${queue}/info/master

  separator=${IFS} ; IFS=";"

  for host in ${hostlist} ; do
    m=${host%%:*}
    p=${host#*:}; p=${p%:*}
    n=${host##*:}

		echo "${m}"      >> ${vardir}/${queue}/info/hosts
    echo "${m}:${p}" >> ${vardir}/${queue}/info/nproc
    echo "${m}:${n}" >> ${vardir}/${queue}/info/nice
  done

  IFS=${separator}
fi

if [ "x${persistent}" = "xyes" ] ; then
  touch ${vardir}/${queue}/info/persistent
fi

sqslock ${vardir}/${queue} ${key} || exit $?
sqsunlock ${vardir} ${key} || exit $?

separator=$IFS ; IFS=";"

for task in ${tasklist} ; do
  i=`cat ${vardir}/${queue}/info/ntask`
  ((i++))
  echo "sqs: add task ${i} '${task}'"
  echo ${task} > ${vardir}/${queue}/wait/${i}
  echo ${i}    > ${vardir}/${queue}/info/ntask
done

IFS=${separator}

sqsunlock ${vardir}/${queue} ${key} || exit $?

if [ "x${createonly}" != "xyes" ] ; then
  separator=$IFS ; IFS=";"

  for host in ${hostlist} ; do
    host=${host%%:*}
    # seed sqsrunner
    if [ "x${verbose}" = "xyes" ] ; then
      echo "sqs: seeding runners on '${host}'!"
    fi

    if [ "${host}" = "$(hostname)" ] ; then
      sqsrunner ${vardir}/${queue} &
    else 
      ssh ${host} "verbose=${verbose} sqsrunner ${vardir}/${queue}" &
    fi
  done

  IFS=${separator}
fi

if [ "x${verbose}" = "xyes" ] ; then
  echo "sqs: finished!"
fi
