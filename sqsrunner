#!/bin/bash

#
# Helper script for the SQS
# Retrieves sucessively tasks from queue and waits for their completion
#

#_______________________________________________________________________________
sqsr_add_to_runc()
{
  # add parameter to runner count
  # helper function used to increment or decrement runner count,
  # current runner count is returned.
  #
  local nrun=$(grep ${host} ${queue}/info/hosts)
  nrun=${nrun#*:}
  if [ ${1} -ne 0 ] ; then
    ((nrun=nrun+${1}))
    grep -v ${host} ${queue}/info/hosts > ${queue}/info/hosts.tmp
    mv ${queue}/info/hosts.tmp ${queue}/info/hosts
    echo "${host}:${nrun}" >> ${queue}/info/hosts
  fi
  echo ${nrun}
  return
}


################################################################################
# script entry point
#

source sqsconfig

if [ $# -ne 1 ] ; then
    echo "sqsrunner ($$): wrong argument count! ($*) [$(hostname)]"
    exit 1
fi

queue=${1}

if ! [ -e ${queue} ] ; then
    echo "sqsrunner ($$): queue '${queue}' does not exist! [${host}]"
    exit 2
fi

host=$(hostname)
key="${host}.$$"

sqslock ${queue} ${key} || exit $?

# Increment runner count
nrun=$(sqsr_add_to_runc 1)

if [ "x${verbose}" = "xyes" ] ; then
  echo "sqsrunner ($$): starting runner, ${nrun} runners on ${host}."
fi

while [ true ] ; do
  # retrieve runner count on host
  nrun=$(sqsr_add_to_runc 0)

  # retrieve number of allowed runners for host
  nmax=`cat ${queue}/info/nproc | grep ${host} | sed "s|^.*:||"`

  if [ "x${verbose}" = "xyes" ] ; then
    echo "sqsrunner ($$): ${nrun} of ${nmax} processes [${host}]"
  fi

  # exit loop if above maximum
  if [ ${nrun} -gt ${nmax} ] ; then
    sqsunlock ${queue} ${key} || exit $?
    break
  fi

  # retrieve first task from queue
  tid=`ls ${queue}/wait 2>/dev/null | sort -n | head -n 1`

  if [ "x${tid}" = "x" ] ; then
    if [ "x${verbose}" = "xyes" ] ; then
      echo "sqsrunner ($$): no more tasks in list [${host}]"
    fi

    persist=$(sqsgetopt ${queue} "persist" "no")

    if [ "x${persist}" = "xyes" ] && [ ${nrun} -eq 1 ] ; then
      sqsunlock ${queue} ${key} || exit $?
      if [ "x${verbose}" = "xyes" ] ; then
        echo "sqsrunner ($$): ideling [${host}]"
      fi
      sleep 1
      sqslock ${queue} ${key} || exit $?
      continue
    fi
    # exit loop if not a busy queue
    break
  fi

  # seed runners if below maximum
  if [ "${nrun}" -lt "${nmax}" ] ; then
    sqsrunner ${queue} &

    if [ "x${verbose}" = "xyes" ] ; then
      echo "sqsrunner ($$): spawning new sqsrunner ($!) [${host}]"
    fi
  fi

  task=`cat ${queue}/wait/${tid}`

  # retrieve nice level of queue for host
  nlvl=`cat ${queue}/info/nice | grep ${host} | sed "s|^.*:||"`

  # retrieve ionice level of queue for host
  #iolv=`cat ${queue}/info/ionice | grep ${host} | sed "s|^.*:||"`

  # move task to exec
  mv -f ${queue}/wait/${tid} ${queue}/exec/

  if [ "x${verbose}" = "xyes" ] ; then
    echo "sqsrunner ($$): executing task ${tid}: '${task}' (nice ${nlvl}) [${host}]"
  fi

  # start task
  nice -n ${nlvl} ${task} &
  pid=$!

  # update proc
  echo "${tid}" > ${queue}/proc/${host}.${pid}

  sqsunlock ${queue} ${key} || exit $?

  # wait for completion
  wait ${pid}

  # remove completed task
  sqslock ${queue} ${key} || exit $?
  rm -f ${queue}/exec/${tid}
  rm -f ${queue}/proc/${host}.${pid}
done

# Decrement runner count
nrun=$(sqsr_add_to_runc -1)

if [ "x${verbose}" = "xyes" ] ; then
  echo "sqsrunner ($$): exiting runner, runners on ${host}: ${nrun}"
fi

# Determine total number of runners on all hosts
trun=0;

for h in $(cat ${queue}/info/hosts) ; do
  nrun=${h#*:}
  ((trun+=nrun))
done

if [ ${trun} -ne 0 ] ; then
  if [ "x${verbose}" = "xyes" ] ; then
    echo "sqsrunner ($$): total count ${trun}, leaving queue '${queue}' [${host}]"
  fi

  sqsunlock ${queue} ${key} || exit $?
  exit 0
fi

# If the queue is persistent, leave - also if there are no more runners
persist=$(sqsgetopt ${queue} "persist" "no")

if [ "$x${persist}" = "xyes" ] ; then
  if [ "x${verbose}" = "xyes" ] ; then
    echo "sqsrunner ($$): leaving persistent queue '${queue}' [${host}]"
  fi

  sqsunlock ${queue} ${key} || exit $?
  exit 0
fi

# Queue is empty and not persistent, try to close queue
sqslock ${vardir} ${key} || exit $?

if [ "x${verbose}" = "xyes" ] ; then
  echo "sqsrunner ($$): closing queue '${queue}' [${host}]"
fi

rm -r ${queue}

sqsunlock ${vardir} ${key} || exit $?

if [ "x${verbose}" = "xyes" ] ; then
  echo "sqsrunner ($$): queue '${queue}' closed [${host}]"
fi

exit 0

### EOF
